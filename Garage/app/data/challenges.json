[
    {
        "id": "intern_01_xerox_object_creation",
        "title": "Nascimento do Objeto",
        "description": "Ao criar um objeto de domínio, qual é a invariante mais importante a ser aplicada?",
        "context_code": "// Qual abordagem esta correta?\n// A) new Account() e depois account.setId(...); account.setBalance(...);\n// B) new Account(id, initialBalance)  // validado no construtor",
        "category": "domain_modeling",
        "required_stage": "Intern",
        "region": "Xerox PARC",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Objetos devem ser criados vazios e preenchidos via setters para flexibilidade",
                "is_correct": false,
                "explanation": "Um objeto com setters públicos pode existir em estado inválido. Isso é fonte de bugs em sistemas concorrentes."
            },
            {
                "text": "Objetos devem nascer válidos. Todo estado obrigatório deve ser fornecido no momento da construção.",
                "is_correct": true,
                "explanation": "Se um objeto pode existir em estado inválido, todo método precisa verificar validade. Validação no construtor elimina essa classe inteira de bugs."
            },
            {
                "text": "Depende do framework sendo utilizado",
                "is_correct": false,
                "explanation": "Regras de domínio não dependem de frameworks. O princípio de construção válida se aplica independente da tecnologia."
            }
        ]
    },
    {
        "id": "intern_02_xerox_naming",
        "title": "Nomes Revelam Intenção",
        "description": "Você encontra uma variável chamada 'd' no código. O que um engenheiro faz?",
        "context_code": "int d; // tempo decorrido em dias\nvs.\nint elapsedTimeInDays;",
        "category": "domain_modeling",
        "required_stage": "Intern",
        "region": "Xerox PARC",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Nomes curtos são melhores porque digitamos menos",
                "is_correct": false,
                "explanation": "Código é lido 10x mais do que é escrito. Economia de digitação custa horas de depuração."
            },
            {
                "text": "Use nomes que revelam intenção: 'elapsedTimeInDays' é autoexplicativo",
                "is_correct": true,
                "explanation": "Clean Code: nomes devem responder POR QUE existe, O QUE faz e COMO é usado. Se precisa de comentário para explicar, o nome está errado."
            },
            {
                "text": "Tanto faz, o compilador não liga para nomes",
                "is_correct": false,
                "explanation": "O compilador não liga, mas o engenheiro que mantém seu código às 3h da manhã liga muito."
            }
        ]
    },
    {
        "id": "intern_03_xerox_functions",
        "title": "Funções Pequenas",
        "description": "Uma função tem 200 linhas e faz 5 coisas diferentes. Qual o problema?",
        "context_code": "void processOrder() {\n  // valida input (40 linhas)\n  // calcula preco (50 linhas)\n  // aplica desconto (30 linhas)\n  // salva no banco (40 linhas)\n  // envia email (40 linhas)\n}",
        "category": "domain_modeling",
        "required_stage": "Intern",
        "region": "Xerox PARC",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Nenhum problema -- funções grandes são mais eficientes",
                "is_correct": false,
                "explanation": "Funções grandes são impossíveis de testar, reutilizar e entender. São a principal fonte de bugs em sistemas legados."
            },
            {
                "text": "Viola o princípio de responsabilidade única: cada função deve fazer UMA coisa bem feita",
                "is_correct": true,
                "explanation": "Extraia 5 funções: validateInput(), calculatePrice(), applyDiscount(), saveOrder(), sendConfirmation(). Cada uma testável isoladamente, reutilizável e com nome que revela intenção."
            },
            {
                "text": "Só é problema se tiver mais de 500 linhas",
                "is_correct": false,
                "explanation": "Não existe limiar mágico. Se a função faz mais de uma coisa, já está errada. Funções ideais têm 5-20 linhas."
            }
        ]
    },
    {
        "id": "intern_04_apple_hello_world",
        "title": "O Primeiro Contrato",
        "description": "Qual é o propósito principal de escrever código segundo a disciplina de engenharia?",
        "context_code": null,
        "category": "domain_modeling",
        "required_stage": "Intern",
        "region": "Apple Garage",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Escrever o código mais curto possível (one-liners)",
                "is_correct": false,
                "explanation": "Brevidade não é o objetivo. Clareza e manutenibilidade são. Código é lido 10x mais do que é escrito."
            },
            {
                "text": "Criar um contrato imutável e auditável para o futuro",
                "is_correct": true,
                "explanation": "Código é um contrato. Outro engenheiro vai mantê-lo daqui a 3 anos. Precisa ser claro, testável e resiliente a mudanças."
            },
            {
                "text": "Usar a sintaxe mais moderna e os recursos mais recentes do framework",
                "is_correct": false,
                "explanation": "Frameworks mudam. Sintaxe evolui. Fundamentos permanecem. Projete para longevidade, não para tendências."
            }
        ]
    },
    {
        "id": "intern_05_apple_data_structures",
        "title": "ArrayList vs LinkedList",
        "description": "Em um ambiente de produção de Big Tech, por que ArrayList geralmente supera LinkedList em performance?",
        "context_code": "// Java\nList<User> users = new ArrayList<>();  // vs LinkedList<>()\nfor (User u : users) { process(u); }",
        "category": "logic",
        "required_stage": "Intern",
        "region": "Apple Garage",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Porque ArrayList usa menos memória no total",
                "is_correct": false,
                "explanation": "O uso de memória sozinho não determina performance. O fator chave é o comportamento do cache da CPU."
            },
            {
                "text": "Porque ArrayList tem acesso aleatório O(1) enquanto LinkedList tem O(n)",
                "is_correct": false,
                "explanation": "Embora a complexidade de acesso seja diferente, o impacto real em produção é a localidade de cache, não apenas o Big-O."
            },
            {
                "text": "Porque ArrayList se beneficia da localidade de cache da CPU (memória contígua), reduzindo cache misses",
                "is_correct": true,
                "explanation": "A CPU busca memória em cache lines (64 bytes). ArrayList armazena elementos de forma contígua, então o prefetcher trabalha eficientemente. LinkedList espalha nós pelo heap, causando cache misses em cada travessia."
            }
        ]
    },
    {
        "id": "intern_06_apple_types",
        "title": "Tipos Primitivos vs Objetos",
        "description": "Por que usar um Value Object 'Email' ao invés de uma String simples?",
        "context_code": "// Abordagem A:\nString email = userInput;\n// Abordagem B:\nEmail email = new Email(userInput); // valida formato no construtor",
        "category": "domain_modeling",
        "required_stage": "Intern",
        "region": "Apple Garage",
        "mentor": "The Craftsman",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Não faz diferença, ambos armazenam texto",
                "is_correct": false,
                "explanation": "String aceita qualquer texto: 'gato', '123', vazio. Não há garantia de que é um email válido em nenhum ponto do sistema."
            },
            {
                "text": "Value Object encapsula validação: se existe, está válido. Elimina bugs de estado inválido em todo o sistema.",
                "is_correct": true,
                "explanation": "Com Value Object, a validação acontece UMA vez (no construtor). Todo código que recebe um Email sabe que é válido. Isso é o princípio 'Make illegal states unrepresentable'."
            },
            {
                "text": "É apenas uma questão de preferência pessoal",
                "is_correct": false,
                "explanation": "Não é preferência. É engenharia. Primitive Obsession é um code smell documentado. Em sistemas financeiros, confundir 'id de conta' com 'string qualquer' causa bugs críticos."
            }
        ]
    },
    {
        "id": "junior_01_microsoft_domain",
        "title": "Domínio Primeiro",
        "description": "Um desenvolvedor junior é solicitado a implementar uma funcionalidade de transferência bancária. O que ele deve fazer PRIMEIRO?",
        "context_code": null,
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Microsoft",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Criar o endpoint REST e as tabelas do banco de dados",
                "is_correct": false,
                "explanation": "Começar pela infraestrutura acopla seu design a detalhes técnicos. O domínio deve ser definido primeiro."
            },
            {
                "text": "Encontrar um framework que lide com transferencias automaticamente",
                "is_correct": false,
                "explanation": "Frameworks resolvem problemas genéricos. Suas regras de negócio são específicas. Delegar sem entender é perigoso."
            },
            {
                "text": "Modelar o domínio: O que é uma transferência? Quem autoriza? Quais estados são inválidos?",
                "is_correct": true,
                "explanation": "Engenheiros modelam o espaço do problema antes de escrever código. Quais são as entidades? Quais são as invariantes? Quais transições são ilegais? Isso é Domain-Driven Design."
            }
        ]
    },
    {
        "id": "junior_02_microsoft_immutability",
        "title": "Estado e o Inimigo",
        "description": "Uma classe tem 12 métodos setter públicos. O que isso indica sobre seu design?",
        "context_code": "public class Order {\n    public void setId(String id) { ... }\n    public void setStatus(String status) { ... }\n    public void setCustomer(Customer c) { ... }\n    // ... mais 9 setters\n}",
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Microsoft",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "É um JavaBean bem projetado com máxima flexibilidade",
                "is_correct": false,
                "explanation": "Flexibilidade sem restrições é caos. Qualquer chamador pode colocar este objeto em estado inválido a qualquer momento."
            },
            {
                "text": "É uma estrutura de dados anêmica que mente sobre suas responsabilidades",
                "is_correct": true,
                "explanation": "Um objeto cheio de setters não é um objeto -- é um saco de dados mutável. Não consegue proteger suas invariantes. Em sistemas concorrentes, isso leva a race conditions e corrupção de dados."
            },
            {
                "text": "É ideal para injeção de dependências",
                "is_correct": false,
                "explanation": "Injeção de dependências usa injeção via construtor para dependências obrigatórias, não mutação baseada em setters."
            }
        ]
    },
    {
        "id": "junior_03_microsoft_layers",
        "title": "Camadas de Responsabilidade",
        "description": "Onde as regras de negócio devem residir em um sistema bem arquitetado?",
        "context_code": null,
        "category": "architecture",
        "required_stage": "Junior",
        "region": "Microsoft",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Na camada Controller, perto da requisicao HTTP",
                "is_correct": false,
                "explanation": "Controllers são adaptadores. Traduzem HTTP para chamadas de domínio. Regras de negócio em controllers não podem ser reutilizadas ou testadas isoladamente."
            },
            {
                "text": "Na camada de Domínio, independente de qualquer framework ou infraestrutura",
                "is_correct": true,
                "explanation": "A camada de domínio deve compilar e rodar sem nenhum framework. Este é o princípio central da Arquitetura Hexagonal. Spring, FastAPI, Express -- todos são detalhes."
            },
            {
                "text": "Na camada de Banco de Dados, usando stored procedures",
                "is_correct": false,
                "explanation": "Banco de dados é infraestrutura. Regras de negócio presas em stored procedures não podem ser testadas unitariamente, versionadas adequadamente ou migradas."
            }
        ]
    },
    {
        "id": "junior_04_nubank_validation",
        "title": "Validação na Fronteira",
        "description": "Um usuário envia um CPF inválido para a API. Onde e QUANDO a validação deve acontecer?",
        "context_code": "// POST /api/pix\n// { \"cpf\": \"000.000.000-00\", \"amount\": 150.00 }",
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Nubank",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "No banco de dados, com uma constraint CHECK",
                "is_correct": false,
                "explanation": "Se o dado inválido chega ao banco, já percorreu todo o sistema. Validação deve ser fail-fast: na entrada."
            },
            {
                "text": "Na fronteira de entrada (API/Controller), antes de entrar no domínio. Input inválido nunca deve cruzar o limite.",
                "is_correct": true,
                "explanation": "Input validation é a primeira linha de defesa. Na Arquitetura Hexagonal, o Adapter valida formato, o Domain valida regras de negócio. CPF inválido é rejeitado antes de consumir recursos."
            },
            {
                "text": "No frontend apenas, para melhor experiência do usuário",
                "is_correct": false,
                "explanation": "Frontend pode ser burlado. Um curl ou Postman ignora toda validação de UI. O backend DEVE validar independentemente."
            }
        ]
    },
    {
        "id": "junior_05_nubank_exceptions",
        "title": "Tratamento de Erros",
        "description": "Uma transferência Pix falha porque o destinatário não existe. Como o sistema deve responder?",
        "context_code": "// O que retornar?\n// A) return null;\n// B) throw new RuntimeException(\"erro\");\n// C) return Result.failure(RecipientNotFound(cpf));",
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Nubank",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Retornar null e deixar o chamador verificar",
                "is_correct": false,
                "explanation": "Null é ambíguo: significa erro? Vazio? Não encontrado? É a maior fonte de NullPointerException em produção. Tony Hoare chamou null de 'erro de um bilhão de dólares'."
            },
            {
                "text": "Usar o padrão Result/Either: retornar um objeto tipado que explica exatamente o que aconteceu",
                "is_correct": true,
                "explanation": "Result.failure(RecipientNotFound(cpf)) é explícito, tipado e força o chamador a tratar o caso. Sem ambiguidade, sem exceções silenciosas, sem logs perdidos."
            },
            {
                "text": "Lançar uma exceção genérica e capturar no handler global",
                "is_correct": false,
                "explanation": "Exceções genéricas perdem contexto. 'RuntimeException: erro' não ajuda ninguém às 3h da manhã. Erros devem ser específicos, rastreáveis e acionáveis."
            }
        ]
    },
    {
        "id": "junior_06_nubank_testing",
        "title": "O Que Testar Primeiro",
        "description": "Você tem 2 horas para escrever testes em um módulo novo de Pix. O que priorizar?",
        "context_code": null,
        "category": "architecture",
        "required_stage": "Junior",
        "region": "Nubank",
        "mentor": "The Refactorer",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Testes de UI end-to-end para cobrir tudo de uma vez",
                "is_correct": false,
                "explanation": "Testes E2E são lentos, frágeis e caros de manter. A pirâmide de testes prioriza unitários na base."
            },
            {
                "text": "Testes unitários nas regras de domínio: limites de transferência, saldo insuficiente, CPF inválido",
                "is_correct": true,
                "explanation": "Regras de domínio são o núcleo do valor. Testar que saldo insuficiente bloqueia transferência, que limite diário é respeitado, que CPF inválido é rejeitado. Esses testes rodam em milissegundos e cobrem o que importa."
            },
            {
                "text": "Testes de performance com JMeter",
                "is_correct": false,
                "explanation": "Performance é importante, mas sem testes de corretude primeiro, você está otimizando código que pode estar errado."
            }
        ]
    },
    {
        "id": "mid_01_google_hashmap",
        "title": "HashMap vs TreeMap",
        "description": "Você precisa implementar um Rate Limiter que verifica quantas requisições aconteceram nos últimos 60 segundos. Qual estrutura de dados usar?",
        "context_code": "// Requisitos:\n// - Rastrear timestamps de requisicoes por usuario\n// - Contar requisicoes em uma janela deslizante de 60 segundos\n// - Consultas por faixa O(log n) necessarias",
        "category": "logic",
        "required_stage": "Mid",
        "region": "Google",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "HashMap -- é sempre mais rápido com busca O(1)",
                "is_correct": false,
                "explanation": "HashMap fornece busca pontual O(1), mas não consegue fazer consultas por faixa. Você precisa encontrar todos os timestamps entre agora-60s e agora. HashMap exige varrer todas as entradas."
            },
            {
                "text": "TreeMap -- suporta consultas por faixa (subMap) para a janela deslizante",
                "is_correct": true,
                "explanation": "TreeMap mantém ordem classificada. subMap(agora-60s, agora) retorna todas as requisições na janela em O(log n). Esta é a estrutura correta para problemas de janela deslizante."
            },
            {
                "text": "ArrayList -- apenas adicione timestamps e itere",
                "is_correct": false,
                "explanation": "ArrayList append é O(1) amortizado, mas encontrar a janela exige varredura O(n) ou busca binária manual. TreeMap faz isso nativamente."
            }
        ]
    },
    {
        "id": "mid_02_google_framework",
        "title": "Framework vs Domínio",
        "description": "Qual é a relação correta entre a camada de Domínio e um Framework como Spring ou FastAPI?",
        "context_code": "# Qual esta correto?\n# A) domain/ importa de fastapi\n# B) api/ importa de domain/\n# C) Ambos importam um do outro",
        "category": "architecture",
        "required_stage": "Mid",
        "region": "Google",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "O Domínio depende do Framework",
                "is_correct": false,
                "explanation": "Se o domínio importa classes do framework, trocar de framework significa reescrever regras de negócio. Essa é a definição de acoplamento forte."
            },
            {
                "text": "São a mesma coisa",
                "is_correct": false,
                "explanation": "Confundir framework com arquitetura é um erro fundamental de design. O framework é uma ferramenta; o domínio é o valor."
            },
            {
                "text": "O Framework é um detalhe que aponta para dentro, em direção ao Domínio (Inversão de Dependência)",
                "is_correct": true,
                "explanation": "Na Arquitetura Hexagonal, dependências apontam para dentro. O domínio é o centro. Frameworks, bancos de dados e APIs são adaptadores do lado de fora. O domínio deve compilar sem eles."
            }
        ]
    },
    {
        "id": "mid_03_google_complexity",
        "title": "Complexidade Algorítmica",
        "description": "Você tem um array de 1 milhão de elementos ordenados. Qual a forma mais eficiente de encontrar um elemento?",
        "context_code": "// array = [1, 3, 5, 7, ..., 999999]\n// Encontrar: 742831",
        "category": "logic",
        "required_stage": "Mid",
        "region": "Google",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Iterar do início até encontrar: O(n), no máximo 1 milhão de comparações",
                "is_correct": false,
                "explanation": "Busca linear ignora que o array está ordenado. Você está jogando fora informação valiosa."
            },
            {
                "text": "Busca Binária: dividir ao meio a cada passo, O(log n) = ~20 comparações para 1 milhão de elementos",
                "is_correct": true,
                "explanation": "Busca binária corta o espaço de busca pela metade a cada iteração. log2(1.000.000) = ~20. De 1 milhão para 20 comparações. Essa é a diferença entre pensar algoritmicamente e usar força bruta."
            },
            {
                "text": "Usar um HashMap para busca O(1)",
                "is_correct": false,
                "explanation": "HashMap usa O(n) espaço extra e destrói a ordem. Se o dado já está ordenado, busca binária é O(log n) sem espaço extra. Não desperdice recursos."
            }
        ]
    },
    {
        "id": "mid_04_facebook_tdd",
        "title": "Desenvolvimento Orientado a Testes",
        "description": "Qual é a ordem correta dos passos no TDD?",
        "context_code": null,
        "category": "architecture",
        "required_stage": "Mid",
        "region": "Facebook",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Escrever código, depois testes, depois refatorar",
                "is_correct": false,
                "explanation": "Escrever testes depois do código leva a testes que verificam implementação, não comportamento. Ficam frágeis e inúteis."
            },
            {
                "text": "Red (teste falhando), Green (fazê-lo passar), Refactor (limpar)",
                "is_correct": true,
                "explanation": "TDD força você a pensar no contrato antes da implementação. O teste define O QUE, o código define COMO. Refatoração garante qualidade."
            },
            {
                "text": "Escrever todos os testes primeiro, depois implementar tudo de uma vez",
                "is_correct": false,
                "explanation": "TDD funciona em ciclos incrementais pequenos. Escrever todos os testes primeiro perde o loop de feedback que torna o TDD poderoso."
            }
        ]
    },
    {
        "id": "mid_05_facebook_graphs",
        "title": "Grafos Sociais",
        "description": "No Facebook, cada usuário é um nó e cada amizade é uma aresta. Para encontrar 'amigos de amigos', qual algoritmo usar?",
        "context_code": "// Grafo: User A -> [B, C]\n//        User B -> [A, D, E]\n// 'Amigos de amigos de A' = {D, E}",
        "category": "logic",
        "required_stage": "Mid",
        "region": "Facebook",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "DFS (busca em profundidade) -- vai até o fundo do grafo",
                "is_correct": false,
                "explanation": "DFS explora profundamente, o que pode ir longe demais no grafo social. Para 'amigos de amigos' (distância 2), você precisa de busca por nível."
            },
            {
                "text": "BFS (busca em largura) ate profundidade 2 -- explora nivel por nivel",
                "is_correct": true,
                "explanation": "BFS explora todos os vizinhos de nível 1 (amigos), depois todos de nível 2 (amigos de amigos). Controla a profundidade naturalmente. É o algoritmo padrão para busca por proximidade em grafos sociais."
            },
            {
                "text": "Ordenar a lista de usuarios e usar busca binaria",
                "is_correct": false,
                "explanation": "Grafos não são arrays. Busca binária requer dados ordenados linearmente. Relações sociais são conexões, não sequências."
            }
        ]
    },
    {
        "id": "mid_06_facebook_concurrency",
        "title": "Concorrência em Escala",
        "description": "Dois usuários curtem o mesmo post simultaneamente. O contador mostra 1 ao invés de 2. Qual o problema?",
        "context_code": "// Thread A: count = getCount(); // retorna 0\n// Thread B: count = getCount(); // retorna 0\n// Thread A: setCount(count + 1); // seta 1\n// Thread B: setCount(count + 1); // seta 1 (deveria ser 2!)",
        "category": "logic",
        "required_stage": "Mid",
        "region": "Facebook",
        "mentor": "The Simplifier",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Bug no banco de dados -- o INSERT falhou silenciosamente",
                "is_correct": false,
                "explanation": "O banco não falhou. O problema é lógico: ler-modificar-escrever sem atomicidade é uma race condition clássica."
            },
            {
                "text": "Race condition: ler-modificar-escrever não é atômico. Solução: usar operação atômica (CAS ou incremento atômico)",
                "is_correct": true,
                "explanation": "A operação correta é atomicCounter.incrementAndGet() ou UPDATE posts SET count = count + 1 (atômico no banco). Nunca leia, modifique e escreva em passos separados sem lock ou operação atômica."
            },
            {
                "text": "Colocar um sleep() entre as operacoes para evitar colisao",
                "is_correct": false,
                "explanation": "Sleep não resolve race conditions. Apenas reduz a probabilidade. Em escala do Facebook (bilhões de interações), a colisão ACONTECERÁ."
            }
        ]
    },
    {
        "id": "senior_01_amazon_performance",
        "title": "Performance e Arquitetura",
        "description": "De onde vem a melhoria real de performance em sistemas de produção?",
        "context_code": "// O que importa mais?\n// A) Otimizar iteracoes de for-loop\n// B) Reduzir pressao do GC, I/O assincrono, entender distribuicao de latencia",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "Amazon",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Otimizar for-loops individuais e micro-benchmarks",
                "is_correct": false,
                "explanation": "Micro-otimização é amadorismo. O gargalo quase nunca é um loop. É I/O, pausas do GC, saltos de rede e fluxo de dados mal projetado."
            },
            {
                "text": "Menos alocações (pressão do GC), I/O assíncrono (não-bloqueante) e entender latência p99",
                "is_correct": true,
                "explanation": "Performance real é arquitetural. Reduza alocação de objetos para diminuir pressão do GC. Use I/O não-bloqueante para throughput. Monitore latência p99, não médias -- a cauda mata a experiência do usuário."
            },
            {
                "text": "Usar a linguagem de programacao mais rapida disponivel (Rust/C++)",
                "is_correct": false,
                "explanation": "A escolha da linguagem importa menos que o design arquitetural. Um sistema Java bem projetado supera um sistema Rust mal projetado."
            }
        ]
    },
    {
        "id": "senior_02_amazon_twosum",
        "title": "Two Sum (O Clássico)",
        "description": "Dado um array de inteiros e uma soma alvo, encontre dois números que somam ao alvo. Qual é a abordagem ótima?",
        "context_code": "// Input: nums = [2, 7, 11, 15], target = 9\n// Output: [0, 1] (porque nums[0] + nums[1] = 9)",
        "category": "logic",
        "required_stage": "Senior",
        "region": "Amazon",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Loops aninhados: verificar cada par. Tempo O(n^2).",
                "is_correct": false,
                "explanation": "Força bruta funciona mas não escala. Com 1 milhão de elementos, são 10^12 operações. Inaceitável."
            },
            {
                "text": "Ordenar o array, depois usar dois ponteiros. Tempo O(n log n).",
                "is_correct": false,
                "explanation": "Melhor que força bruta, mas ordenar modifica os índices originais. Você precisa de controle extra. Existe uma solução O(n)."
            },
            {
                "text": "Usar um HashMap: para cada número, verificar se (alvo - número) existe. Tempo O(n).",
                "is_correct": true,
                "explanation": "Passagem única. Para cada elemento x, verifique se (alvo - x) está no mapa. Se sim, retorne índices. Se não, armazene x. Tempo O(n), espaço O(n). Esta é a resposta esperada em toda entrevista de Big Tech."
            }
        ]
    },
    {
        "id": "senior_03_amazon_resilience",
        "title": "Resiliência: Circuit Breaker",
        "description": "Um microserviço depende de um serviço externo que está fora do ar. O que acontece sem Circuit Breaker?",
        "context_code": "// Servico A -> Servico B (fora do ar)\n// 1000 req/s chegando em A\n// Cada req espera 30s de timeout em B",
        "category": "distributed_systems",
        "required_stage": "Senior",
        "region": "Amazon",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "As requisicoes simplesmente falham rapido e o usuario recebe um erro",
                "is_correct": false,
                "explanation": "Sem circuit breaker, as requisições NÃO falham rápido. Cada uma espera o timeout (30s), acumulando threads bloqueadas até esgotar o pool."
            },
            {
                "text": "Cascata de falhas: threads bloqueadas esgotam o pool, Serviço A também para de responder. Circuit Breaker corta o circuito após N falhas.",
                "is_correct": true,
                "explanation": "Circuit Breaker monitora falhas. Após um limiar (ex: 5 falhas em 10s), abre o circuito: rejeita requisições imediatamente sem chamar B. Periodicamente testa se B voltou (half-open). Isso isola a falha e protege o sistema."
            },
            {
                "text": "So aumentar o timeout para dar mais tempo ao servico",
                "is_correct": false,
                "explanation": "Aumentar o timeout PIORA o problema. Mais threads ficam bloqueadas por mais tempo. O padrão correto é fail fast com circuit breaker."
            }
        ]
    },
    {
        "id": "senior_04_meli_idempotency",
        "title": "Idempotência em Pagamentos",
        "description": "O Mercado Pago processa uma compra duas vezes porque o cliente clicou 2x no botão. Como evitar cobrança duplicada?",
        "context_code": "// POST /api/pay\n// { amount: 299.90, buyer_id: 'abc', idempotency_key: '???' }",
        "category": "distributed_systems",
        "required_stage": "Senior",
        "region": "Mercado Livre",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Desabilitar o botao no frontend apos o primeiro clique",
                "is_correct": false,
                "explanation": "Frontend pode ser burlado. Falhas de rede causam retentativas implícitas. O servidor DEVE ser idempotente independente do cliente."
            },
            {
                "text": "Exigir uma chave de idempotência por requisição e armazenar chaves processadas para detectar duplicatas",
                "is_correct": true,
                "explanation": "Uma chave de idempotência identifica unicamente cada operação pretendida. O servidor armazena chaves processadas e retorna o resultado em cache para duplicatas. Este é o padrão em Stripe, Mercado Pago e todos os sistemas de pagamento sérios."
            },
            {
                "text": "Verificar se o saldo ja foi debitado antes de processar",
                "is_correct": false,
                "explanation": "Em ambiente concorrente, duas requisicoes podem verificar o saldo ao mesmo tempo e ambas concluir que ha saldo. Race condition classica."
            }
        ]
    },
    {
        "id": "senior_05_meli_cache",
        "title": "Estratégia de Cache",
        "description": "A página de um produto no Mercado Livre recebe 50.000 acessos por segundo. Toda requisição consulta o banco. Qual a solução?",
        "context_code": "// GET /product/MLB123456\n// Banco: 5ms por query\n// 50.000 req/s = 250 segundos de query por segundo!",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "Mercado Livre",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Escalar verticalmente o banco: mais CPU, mais RAM",
                "is_correct": false,
                "explanation": "Scaling vertical tem limite físico e custo exponencial. Não resolve o problema fundamental: leituras repetitivas do mesmo dado."
            },
            {
                "text": "Cache em camadas: CDN para assets, Redis/Memcached para dados quentes, com TTL e invalidação por evento",
                "is_correct": true,
                "explanation": "Cache é a arma número 1 contra leitura excessiva. CDN serve conteúdo estático. Redis guarda dados quentes com TTL. Quando o produto muda, um evento invalida o cache. Isso reduz 50k req/s no banco para dezenas."
            },
            {
                "text": "Colocar um sleep de 100ms entre requisições para não sobrecarregar",
                "is_correct": false,
                "explanation": "Throttling no servidor penaliza usuários legítimos. O problema não é excesso de requisições, é excesso de queries ao banco."
            }
        ]
    },
    {
        "id": "senior_06_meli_sharding",
        "title": "Particionamento de Dados",
        "description": "O banco de dados do Mercado Livre tem 500 milhões de produtos. Uma única instância não aguenta. Como escalar?",
        "context_code": "// 500 milhoes de registros\n// Queries por seller_id sao as mais frequentes",
        "category": "distributed_systems",
        "required_stage": "Senior",
        "region": "Mercado Livre",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Replicação: copiar todos os dados para 10 servidores",
                "is_correct": false,
                "explanation": "Replicação ajuda leituras mas não resolve o tamanho dos dados. Cada réplica ainda tem 500M de registros e escritas vão para todas."
            },
            {
                "text": "Sharding por seller_id: distribuir vendedores entre N partições, cada uma com subconjunto dos dados",
                "is_correct": true,
                "explanation": "Sharding (particionamento horizontal) divide os dados. Shard = hash(seller_id) % N. Cada shard guarda ~500M/N registros. Queries por seller_id vão direto ao shard correto. É assim que sistemas como o Mercado Livre escalam para centenas de milhões de produtos."
            },
            {
                "text": "Usar NoSQL que escala automaticamente sem pensar em partições",
                "is_correct": false,
                "explanation": "NoSQL não é mágica. DynamoDB, Cassandra, MongoDB -- todos exigem escolha cuidadosa de partition key. A decisão de sharding permanece."
            }
        ]
    },
    {
        "id": "senior_07_jpmorgan_consistency",
        "title": "Consistência em Transações",
        "description": "Uma transferência entre duas contas deve debitar R$1000 de A e creditar R$1000 em B. O sistema falha após o débito mas antes do crédito. O que acontece?",
        "context_code": "// Passo 1: UPDATE accounts SET balance = balance - 1000 WHERE id = 'A';\n// --- FALHA AQUI ---\n// Passo 2: UPDATE accounts SET balance = balance + 1000 WHERE id = 'B';",
        "category": "distributed_systems",
        "required_stage": "Senior",
        "region": "JP Morgan",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "O dinheiro desaparece -- e preciso corrigir manualmente",
                "is_correct": false,
                "explanation": "Em sistemas bem projetados, isso NUNCA acontece. Transações ACID existem exatamente para prevenir este cenário."
            },
            {
                "text": "Transação ACID: ambas operações estão em uma única transação. Se qualquer parte falha, TODAS são revertidas (ROLLBACK)",
                "is_correct": true,
                "explanation": "ACID = Atomicity, Consistency, Isolation, Durability. Atomicidade garante que ou TUDO acontece ou NADA acontece. O banco reverte o débito automaticamente. Em sistemas financeiros, isso não é opcional."
            },
            {
                "text": "Executar um job de reconciliacao diario para encontrar inconsistencias",
                "is_correct": false,
                "explanation": "Reconciliação é útil como segunda camada, mas o sistema NÃO deve depender dela para consistência. Transações ACID resolvem na raiz."
            }
        ]
    },
    {
        "id": "senior_08_jpmorgan_encryption",
        "title": "Criptografia de Dados Sensíveis",
        "description": "O JP Morgan armazena numeros de conta e SSN dos clientes. Como proteger estes dados em repouso?",
        "context_code": "// Banco de dados:\n// account_number: '1234-5678-9012-3456' -- TEXTO PLANO!\n// ssn: '123-45-6789' -- TEXTO PLANO!",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "JP Morgan",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Confiar na seguranca do banco de dados (firewall e ACL)",
                "is_correct": false,
                "explanation": "Defense in depth: se o banco for comprometido, dados em texto plano são expostos imediatamente. Firewall é necessário mas insuficiente."
            },
            {
                "text": "Criptografia AES-256 em repouso com chaves gerenciadas em HSM (Hardware Security Module), rotação periódica de chaves",
                "is_correct": true,
                "explanation": "PCI DSS e regulação bancária exigem criptografia em repouso. AES-256 é o padrão. Chaves em HSM (não no código!). Rotação periódica limita o impacto de comprometimento. Logs de acesso a chaves para auditoria."
            },
            {
                "text": "Usar Base64 para ofuscar os dados",
                "is_correct": false,
                "explanation": "Base64 NÃO é criptografia. É codificação reversível por qualquer pessoa. Não oferece nenhuma proteção real."
            }
        ]
    },
    {
        "id": "senior_09_jpmorgan_audit",
        "title": "Trilha de Auditoria",
        "description": "Um regulador pede: 'Mostre todas as operações feitas na conta X nos últimos 90 dias'. Seu sistema consegue?",
        "context_code": "// Abordagem A: UPDATE account SET balance = 5000; (sobrescreve estado anterior)\n// Abordagem B: INSERT INTO ledger (account, type, amount, timestamp, actor) VALUES (...);",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "JP Morgan",
        "mentor": "The Pragmatist",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Apenas guardar o saldo atual -- o regulador so precisa ver o estado final",
                "is_correct": false,
                "explanation": "Reguladores precisam de HISTÓRICO completo: quem fez o que, quando, e por que. Saldo atual sem histórico é insuficiente para compliance."
            },
            {
                "text": "Ledger imutável (append-only): cada operação é um registro permanente. Nunca UPDATE, nunca DELETE. Reconstrução completa do histórico.",
                "is_correct": true,
                "explanation": "Sistemas financeiros usam ledger (livro-razão) imutável. Cada transação é um INSERT. Saldo é calculado somando os eventos. ISO 27001, PCI DSS e SOX exigem rastreabilidade completa."
            },
            {
                "text": "Fazer backup diario do banco e guardar por 90 dias",
                "is_correct": false,
                "explanation": "Backup captura snapshots, não operações individuais. Você não consegue rastrear 'quem alterou o que às 14:32 do dia 15'. Granularidade insuficiente."
            }
        ]
    },
    {
        "id": "staff_01_tesla_cap",
        "title": "Teorema CAP",
        "description": "Em um sistema de banco de dados distribuído, ocorre uma partição de rede. Você deve escolher entre consistência e disponibilidade. O que um sistema bancário escolhe?",
        "context_code": "// Teorema CAP:\n// C = Consistencia (toda leitura retorna a escrita mais recente)\n// A = Disponibilidade (toda requisicao recebe uma resposta)\n// P = Tolerancia a Particao (sistema funciona apesar de falhas de rede)\n// Voce so pode garantir 2 de 3.",
        "category": "distributed_systems",
        "required_stage": "Staff",
        "region": "Tesla",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Disponibilidade -- usuários devem sempre receber resposta, mesmo com dados desatualizados",
                "is_correct": false,
                "explanation": "Em sistemas bancários, mostrar saldo desatualizado pode levar a gasto duplo. Um usuário pode sacar dinheiro que não existe."
            },
            {
                "text": "Consistência -- é melhor rejeitar uma requisição do que servir dados financeiros incorretos",
                "is_correct": true,
                "explanation": "Sistemas financeiros escolhem CP (Consistência + Tolerância a Partição). É mais seguro retornar um erro do que permitir estado inconsistente. Isso previne gasto duplo, leituras fantasma e falhas de auditoria."
            },
            {
                "text": "Nenhum -- basta usar uma rede melhor que nunca particione",
                "is_correct": false,
                "explanation": "Partições de rede são inevitáveis em sistemas distribuídos. Fingir que não acontecem é negligência de engenharia."
            }
        ]
    },
    {
        "id": "staff_02_tesla_event_sourcing",
        "title": "Event Sourcing",
        "description": "Por que um sistema armazenaria eventos ao invés de apenas o estado atual?",
        "context_code": "// Tradicional: UPDATE account SET balance = 900 WHERE id = 1;\n// Event Sourcing: INSERT INTO events (type, data) VALUES ('MoneyWithdrawn', '{amount: 100}');",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Tesla",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "É mais performático para leituras",
                "is_correct": false,
                "explanation": "Event sourcing é na verdade mais lento para leituras (você precisa reproduzir eventos). O benefício está em outro lugar."
            },
            {
                "text": "Trilha de auditoria completa: toda mudança de estado é registrada, nada se perde, tudo é reproduzível",
                "is_correct": true,
                "explanation": "Event sourcing oferece um histórico completo e imutável. Você pode reconstruir o estado em qualquer ponto no tempo. Pode debugar problemas de produção reproduzindo eventos. Isso é crítico para sistemas financeiros, compliance e análise forense."
            },
            {
                "text": "Usa menos espaco em disco do que bancos de dados tradicionais",
                "is_correct": false,
                "explanation": "Event sourcing usa MAIS espaço (armazena cada evento, não apenas o estado atual). O trade-off é espaço por auditabilidade."
            }
        ]
    },
    {
        "id": "staff_03_tesla_redundancy",
        "title": "Projetando para Falhar",
        "description": "Um foguete SpaceX tem centenas de sensores. Se um sensor falha, o que o software faz?",
        "context_code": "// sensor_temperature = read(sensor_A); // FALHA!\n// Decisao do software: abortar missao? Usar backup? Ignorar?",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Tesla",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Abortar a missao imediatamente -- seguranca em primeiro lugar",
                "is_correct": false,
                "explanation": "Aborto por falha de um único sensor é overreaction. Sistemas críticos usam redundância para tolerar falhas individuais."
            },
            {
                "text": "Redundância com votação: N sensores medem a mesma coisa. Se 2 de 3 concordam, o outlier é descartado (Triple Modular Redundancy)",
                "is_correct": true,
                "explanation": "TMR (Triple Modular Redundancy) é o padrão em aviação e espacial. 3 sensores votam. Maioria vence. Um sensor defeituoso é isolado automaticamente. O sistema continua operando com degradação graceful."
            },
            {
                "text": "Usar o ultimo valor valido do sensor ate ele voltar",
                "is_correct": false,
                "explanation": "Em ambiente dinâmico (foguete em voo), o último valor pode estar desatualizado em milissegundos. Stale data em sistemas críticos pode ser fatal."
            }
        ]
    },
    {
        "id": "staff_04_itau_legacy",
        "title": "Modernização de Legados",
        "description": "O Itaú tem sistemas COBOL de 40 anos processando milhões de transações por dia. Como modernizar sem parar o banco?",
        "context_code": "// Sistema atual: COBOL rodando em mainframe\n// Desejado: APIs modernas, cloud-native\n// Restricao: ZERO downtime permitido",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Itau",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Reescrever tudo em Java/Go do zero e migrar em big-bang no fim de semana",
                "is_correct": false,
                "explanation": "Big-bang rewrite é o cemitério de projetos de TI. Você perde 40 anos de regras de negócio embutidas em COBOL. O risco é catastrófico."
            },
            {
                "text": "Strangler Fig Pattern: criar APIs modernas que delegam para o legado, migrar funcionalidade por funcionalidade",
                "is_correct": true,
                "explanation": "Strangler Fig (padrão estrangulador) coloca uma fachada moderna na frente do legado. Novas features vão para o sistema novo. Funcionalidades existentes são migradas uma a uma. O legado encolhe gradualmente até ser desligado. Zero downtime, risco controlado."
            },
            {
                "text": "Manter o COBOL para sempre -- funciona, não mexa",
                "is_correct": false,
                "explanation": "Desenvolvedores COBOL estão se aposentando. O risco operacional de depender de tecnologia sem mão de obra qualificada é insustentável a longo prazo."
            }
        ]
    },
    {
        "id": "staff_05_itau_observability",
        "title": "Observabilidade em Produção",
        "description": "O Itaú processa 1 bilhão de transações por mês. Uma transação Pix está demorando 5 segundos. Como diagnosticar?",
        "context_code": "// Pix deveria levar < 100ms\n// Mas 0.1% das transacoes levam > 5 segundos\n// Logs mostram apenas 'Transacao processada com sucesso'",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Itau",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Adicionar mais logs em cada etapa do fluxo",
                "is_correct": false,
                "explanation": "Logs sem correlação são um oceano de texto. Em escala de bilhões, você não consegue rastrear uma transação individual entre centenas de microserviços."
            },
            {
                "text": "Tracing distribuído (OpenTelemetry): cada transação gera um trace ID único que conecta todos os spans entre serviços",
                "is_correct": true,
                "explanation": "OpenTelemetry gera um traceId único por transação. Cada serviço cria um span com início/fim. Jaeger/Grafana Tempo visualizam o caminho completo. Você vê exatamente qual serviço demorou 4.8s dos 5s totais."
            },
            {
                "text": "Rodar o profiler (JProfiler/VisualVM) em produção",
                "is_correct": false,
                "explanation": "Profilers adicionam overhead significativo em produção (10-30% de latência extra). Em sistema bancário com SLA rígido, isso é inaceitável. Tracing distribuído foi projetado para produção com overhead mínimo (<1%)."
            }
        ]
    },
    {
        "id": "staff_06_itau_security",
        "title": "Zero Trust em Banking",
        "description": "Um microserviço interno do Itaú precisa acessar dados de clientes em outro microserviço. Deve confiar porque está na mesma rede interna?",
        "context_code": "// Servico A (interno) -> Servico B (interno)\n// Mesma VPC, mesmo cluster Kubernetes\n// Devemos permitir sem autenticacao?",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Itau",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Sim, serviços internos podem confiar uns nos outros -- o firewall protege",
                "is_correct": false,
                "explanation": "O modelo de 'confiança perimetral' falha quando um atacante entra na rede (lateral movement). A maioria dos breaches bancários começa de dentro."
            },
            {
                "text": "Zero Trust: toda comunicação requer mTLS + JWT + RBAC, independente de estar na mesma rede",
                "is_correct": true,
                "explanation": "Zero Trust assume que a rede já está comprometida. Cada serviço se autentica mutuamente (mTLS), cada request carrega claims de autorização (JWT), e cada endpoint verifica permissões (RBAC). 'Nunca confie, sempre verifique'."
            },
            {
                "text": "Usar API key fixa compartilhada entre os serviços",
                "is_correct": false,
                "explanation": "API key fixa é um segredo estático que não expira, não tem escopo granular e se vazada compromete tudo. Tokens JWT com expiração curta e escopos específicos são o padrão."
            }
        ]
    },
    {
        "id": "staff_07_uber_realtime",
        "title": "Sistemas em Tempo Real",
        "description": "O Uber precisa calcular o preço de uma corrida em tempo real considerando tráfego, demanda e distância. Qual arquitetura?",
        "context_code": "// Inputs: localizacao GPS (a cada 1s), demanda por zona, condicoes de trafego\n// Output: preco dinamico atualizado a cada segundo\n// Restricao: latencia < 200ms",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "Uber",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "REST API sincrona: o app consulta o backend a cada segundo",
                "is_correct": false,
                "explanation": "1 milhão de motoristas * 1 req/s = 1 milhão de req/s. REST síncrono cria gargalo enorme. Cada request abre conexão, serializa, deserializa."
            },
            {
                "text": "Event streaming (Kafka + processamento em tempo real): dados de GPS e demanda fluem como eventos, preco e calculado como stream processing",
                "is_correct": true,
                "explanation": "Kafka ingere milhões de eventos GPS/s. Apache Flink ou Kafka Streams processam em tempo real. Preço é calculado como função do stream (surge pricing). Push via WebSocket para os apps. Latência de milissegundos, throughput de milhões."
            },
            {
                "text": "Calcular o preco no app do cliente, sem backend",
                "is_correct": false,
                "explanation": "Preço no cliente é manipulável e inseguro. Demanda por zona é dado do servidor. Lógica de pricing deve estar no backend por segurança e justiça."
            }
        ]
    },
    {
        "id": "staff_08_uber_geospatial",
        "title": "Matching Motorista-Passageiro",
        "description": "Um passageiro pede uma corrida. Como encontrar o motorista mais próximo entre 50.000 motoristas ativos na cidade?",
        "context_code": "// Passageiro: lat=-23.5505, lon=-46.6333\n// 50.000 motoristas com GPS atualizado a cada 4 segundos\n// Encontrar os 5 mais proximos em < 50ms",
        "category": "logic",
        "required_stage": "Staff",
        "region": "Uber",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Calcular distancia euclidiana para todos os 50.000 e ordenar: O(n log n)",
                "is_correct": false,
                "explanation": "50k cálculos de distância + sort a cada requisição é lento demais. E distância euclidiana não funciona na superfície terrestre (curvatura)."
            },
            {
                "text": "Índice geoespacial (Geohash/R-tree/H3): dividir o mapa em células, buscar apenas motoristas na mesma célula e adjacentes",
                "is_correct": true,
                "explanation": "Geohash divide o mapa em células hierárquicas. Para encontrar motoristas próximos, basta consultar a célula do passageiro + vizinhas. De 50k para ~100 candidatos. Calcular Haversine (distância real na esfera) só para esses 100. O Uber usa H3 (hexagonal grid) da própria engenharia."
            },
            {
                "text": "Colocar todos os motoristas em uma lista e filtrar por distancia maxima",
                "is_correct": false,
                "explanation": "Sem índice espacial, você precisa varrer TODOS os motoristas. Isso é O(n) por query. Em cidade grande com milhões de queries, não escala."
            }
        ]
    },
    {
        "id": "staff_09_uber_consistency",
        "title": "Consistência Eventual vs Forte",
        "description": "O Uber aceita uma corrida. O motorista vê 'corrida aceita' mas o passageiro ainda vê 'procurando motorista'. Qual tipo de consistência está em jogo?",
        "context_code": "// Servico de Matching: atualiza status = 'matched'\n// App do Motorista: le do replica A -> ve 'matched'\n// App do Passageiro: le do replica B -> ve 'searching' (replicacao ainda nao chegou)",
        "category": "distributed_systems",
        "required_stage": "Staff",
        "region": "Uber",
        "mentor": "The Logician",
        "points_on_correct": 100,
        "options": [
            {
                "text": "Bug no sistema -- ambos deveriam ver o mesmo estado",
                "is_correct": false,
                "explanation": "Não é bug. É consistência eventual: a escrita foi feita, mas a replicação entre nós leva tempo (milissegundos a segundos). O sistema convergirá."
            },
            {
                "text": "Consistência eventual: ambos verão o mesmo estado em breve, mas há uma janela de inconsistência aceita para ganhar disponibilidade",
                "is_correct": true,
                "explanation": "Uber opta por AP (Disponibilidade + Tolerância a Partição) para dados de ride status. Consistência eventual é aceitável: em segundos o passageiro verá o motorista. Para pagamentos, porém, usam consistência forte (CP)."
            },
            {
                "text": "Basta usar um unico banco de dados sem replicas",
                "is_correct": false,
                "explanation": "Um único banco em escala global cria ponto único de falha e latência inaceitável para usuários em outras regiões. Replicação é obrigatória para escala."
            }
        ]
    },
    {
        "id": "principal_01_santander_compliance",
        "title": "Compliance Multi-Jurisdicional",
        "description": "O Santander opera em 10 países, cada um com regulações bancárias diferentes (LGPD, GDPR, PSD2, SOX). Como o software lida?",
        "context_code": "// Brasil: LGPD - dados pessoais com consentimento\n// Europa: GDPR - direito ao esquecimento\n// EUA: SOX - controles internos auditaveis\n// Europa: PSD2 - Open Banking obrigatorio",
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Santander",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Uma única implementação global que atende todas as regulações",
                "is_correct": false,
                "explanation": "Regulações são conflitantes. GDPR exige 'direito ao esquecimento'. Regulação bancária exige manter registros por anos. Uma única implementação não resolve."
            },
            {
                "text": "Policy Engine: regras de compliance como configuração por jurisdição, avaliadas em runtime, auditadas por evento",
                "is_correct": true,
                "explanation": "Separe as regras do código. Um Policy Engine avalia 'País=BR -> aplicar LGPD rules'. Cada regra é versionada, auditada e testada isoladamente. Mudança regulatória = nova policy, não novo deploy de código."
            },
            {
                "text": "Ter um time juridico que revisa cada feature antes do deploy",
                "is_correct": false,
                "explanation": "Revisão manual não escala. Com centenas de deploys por dia em 10 países, compliance deve ser automatizada e embedded no pipeline."
            }
        ]
    },
    {
        "id": "principal_02_santander_privacy",
        "title": "Direito ao Esquecimento vs Auditoria",
        "description": "Um cliente europeu do Santander exige que seus dados sejam apagados (GDPR Art. 17). Mas a regulacao bancaria exige manter registros por 7 anos. O que fazer?",
        "context_code": "// GDPR: DELETE customer WHERE id = 'EU-12345'\n// Regulacao bancaria: RETAIN all transactions for 7 years\n// Conflito direto!",
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Santander",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "GDPR tem prioridade -- apagar tudo",
                "is_correct": false,
                "explanation": "Apagar registros financeiros viola regulação bancária e pode resultar em multas de centenas de milhões."
            },
            {
                "text": "Pseudonimização: substituir dados identificáveis por tokens irreversíveis, mantendo registros financeiros anonimizados para auditoria",
                "is_correct": true,
                "explanation": "Pseudonimização atende ambas regulações. Dados pessoais (nome, email) são substituídos por hashes irreversíveis. Transações financeiras mantidas para auditoria, mas não são mais 'dados pessoais' porque não identificam o indivíduo. GDPR Art. 4(5) reconhece pseudonimização explicitamente."
            },
            {
                "text": "Guardar tudo e ignorar o pedido de exclusao",
                "is_correct": false,
                "explanation": "Violar GDPR pode resultar em multa de até 4% do faturamento global anual. Para o Santander, isso são bilhões de euros."
            }
        ]
    },
    {
        "id": "principal_03_santander_resilience",
        "title": "Resiliência Global",
        "description": "Um datacenter do Santander em Madrid cai completamente. 5 milhões de clientes europeus ficam sem acesso. Qual a estratégia?",
        "context_code": "// Datacenter Madrid: DOWN\n// Clientes afetados: 5 milhoes\n// SLA: 99.99% (max 52 minutos de downtime/ano)\n// RTO: < 5 minutos, RPO: 0 (zero data loss)",
        "category": "distributed_systems",
        "required_stage": "Principal",
        "region": "Santander",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Restaurar backup no mesmo datacenter quando voltar",
                "is_correct": false,
                "explanation": "Se o datacenter inteiro caiu (incêndio, desastre natural), pode levar dias. RTO de 5 minutos exige failover automático, não restauração manual."
            },
            {
                "text": "Multi-region active-active: tráfego é distribuído entre datacenters. Failover automático com replicação síncrona e DNS failover",
                "is_correct": true,
                "explanation": "Active-active em múltiplas regiões: Madrid + Frankfurt. Replicação síncrona para RPO=0. Health checks automáticos detectam falha em segundos. DNS failover redireciona tráfego. Clientes nem percebem. Isso é o padrão para bancos globais."
            },
            {
                "text": "Ter um datacenter de backup frio (cold standby) que pode ser ativado em 2 horas",
                "is_correct": false,
                "explanation": "2 horas excedem o RTO de 5 minutos em 24x. Cold standby também perde dados entre o último backup e a falha (RPO > 0). Inaceitável para sistema bancário."
            }
        ]
    },
    {
        "id": "principal_04_bradesco_scaling",
        "title": "Transformação Digital",
        "description": "O Bradesco tem 60 milhoes de clientes, 70% acessam via app. Como garantir que o app aguenta picos de acesso (dia de pagamento)?",
        "context_code": "// Dia normal: 500k req/min\n// Dia de pagamento: 5M req/min (10x)\n// Black Friday: 8M req/min (16x)\n// O sistema precisa escalar automaticamente",
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Bradesco",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Provisionar para o pico máximo o tempo todo -- 8M req/min permanente",
                "is_correct": false,
                "explanation": "Provisionar para pico permanente desperdiça 95% dos recursos em dias normais. Custo proibitivo. Cloud-native é sobre elasticidade."
            },
            {
                "text": "Auto-scaling baseado em métricas: Kubernetes HPA monitora CPU/latência/queue depth e escala pods automaticamente. Load shedding para proteger o core.",
                "is_correct": true,
                "explanation": "HPA (Horizontal Pod Autoscaler) adiciona instâncias quando métricas cruzam thresholds. De 500k para 5M, escala de 10 para 100 pods em minutos. Load shedding rejeita requisições não-críticas em sobrecarga extrema para proteger transações financeiras."
            },
            {
                "text": "Colocar tudo atras de uma CDN para cachear as respostas",
                "is_correct": false,
                "explanation": "CDN funciona para conteúdo estático. Saldo bancário, transferências e Pix são dados dinâmicos e personalizados que não podem ser cacheados em CDN."
            }
        ]
    },
    {
        "id": "principal_05_bradesco_openbanking",
        "title": "Open Banking e APIs",
        "description": "O Banco Central exige que o Bradesco exponha APIs de Open Banking. Terceiros podem consultar dados de clientes (com consentimento). Como projetar?",
        "context_code": "// API publica: GET /open-banking/accounts/{id}/balance\n// Qualquer fintech autorizada pode chamar\n// Milhares de fintechs, milhoes de requisicoes\n// Dados sensiveis de clientes",
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Bradesco",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Expor o banco de dados direto via API REST simples",
                "is_correct": false,
                "explanation": "Expor banco diretamente viola every security principle. Sem rate limiting, sem autenticação granular, sem auditoria. Breach garantido."
            },
            {
                "text": "API Gateway + OAuth2/OIDC + Rate Limiting + Consentimento granular + Auditoria completa por requisição",
                "is_correct": true,
                "explanation": "API Gateway controla acesso. OAuth2 com PKCE para autenticação. Consentimento do cliente registrado e revogável. Rate limiting por fintech (ex: 100 req/min). Cada requisição gera log de auditoria. Padrão Open Banking Brasil (regulação BACEN)."
            },
            {
                "text": "Dar uma senha unica para cada fintech acessar o sistema",
                "is_correct": false,
                "explanation": "Senha única sem expiração, sem escopo, sem revogação é o oposto de segurança moderna. OAuth2 com tokens de curta duração e escopos granulares é o padrão."
            }
        ]
    },
    {
        "id": "principal_06_bradesco_ai",
        "title": "IA Explicavel em Banking",
        "description": "O Bradesco usa IA para aprovar/negar crédito. Um cliente tem o crédito negado. Como garantir que o modelo não é discriminatório?",
        "context_code": "// Modelo ML: input = dados do cliente -> output = score de credito\n// Score < 0.5 = credito negado\n// Regulacao: decisoes automatizadas devem ser explicaveis (LGPD Art. 20)",
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Bradesco",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Remover variáveis sensíveis (raça, gênero) do modelo -- problema resolvido",
                "is_correct": false,
                "explanation": "Remover a variável explícita não basta. Proxies (CEP, escola, bairro) podem codificar discriminação indiretamente. Isso se chama 'indirect discrimination' ou 'proxy bias'."
            },
            {
                "text": "IA Explicável (XAI): SHAP values para explicar cada decisão + fairness metrics (demographic parity, equalized odds) + auditoria periódica do modelo",
                "is_correct": true,
                "explanation": "SHAP values mostram o peso de cada variável na decisão. Fairness metrics medem se o modelo trata grupos diferentes de forma equitativa. Auditoria periódica detecta drift e bias emergente. LGPD Art. 20 garante ao cidadão o direito de explicação de decisões automatizadas."
            },
            {
                "text": "Deixar um humano revisar todas as decisoes do modelo",
                "is_correct": false,
                "explanation": "Revisão humana não escala para milhões de decisões. Humanos também têm vieses. A solução é medir e monitorar fairness sistematicamente."
            }
        ]
    },
    {
        "id": "principal_07_cloud_retry",
        "title": "Retentativa com Backoff",
        "description": "Uma chamada entre microserviços falha devido a um problema temporário de rede. Qual é a estratégia correta de retentativa?",
        "context_code": "// Servico A chama Servico B\n// Servico B retorna HTTP 503 (Service Unavailable)\n// O que o Servico A deve fazer?",
        "category": "distributed_systems",
        "required_stage": "Principal",
        "region": "Cloud Valley",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Retentar imediatamente em um loop contínuo até funcionar",
                "is_correct": false,
                "explanation": "Retentativas imediatas amplificam o problema. Se o servidor está sobrecarregado, bombardeá-lo com retentativas piora tudo. Isso se chama retry storm."
            },
            {
                "text": "Backoff exponencial com jitter: esperar 1s, 2s, 4s... mais um atraso aleatório",
                "is_correct": true,
                "explanation": "Backoff exponencial dá tempo ao serviço que falhou para se recuperar. Jitter (atraso aleatório) impede que todos os clientes retentem no mesmo instante. Este é o padrão usado por AWS, Google Cloud e todo sistema distribuído sério."
            },
            {
                "text": "Nunca retentar -- apenas falhar rapido e avisar o usuario",
                "is_correct": false,
                "explanation": "Falhar na primeira tentativa é agressivo demais. Falhas transientes são normais em sistemas distribuídos. Uma política razoável de retentativa melhora a confiabilidade."
            }
        ]
    },
    {
        "id": "principal_08_cloud_legacy",
        "title": "A Refatoração do Legado",
        "description": "Você herda um monolito de 10 anos sem nenhum teste, processando R$250 milhões em transações diárias. Qual é o primeiro passo correto?",
        "context_code": null,
        "category": "architecture",
        "required_stage": "Principal",
        "region": "Cloud Valley",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Reescrever tudo do zero usando microserviços",
                "is_correct": false,
                "explanation": "Reescrita total de sistemas funcionais é a causa número um de projetos de engenharia fracassados. Você perde anos de conhecimento de negócio embutido."
            },
            {
                "text": "Adicionar testes de caracterização nos caminhos críticos primeiro, depois refatorar incrementalmente",
                "is_correct": true,
                "explanation": "Testes de caracterização capturam o comportamento atual. Uma vez que você tem uma rede de segurança, pode refatorar com confiança. Mudanças pequenas e incrementais são mais seguras que reescrita total. Este é o padrão Strangler Fig."
            },
            {
                "text": "Fazer deploy na cloud e adicionar monitoramento -- o código funciona, não mexa nele",
                "is_correct": false,
                "explanation": "Código funcionando sem testes é uma bomba-relógio. Você não pode corrigir bugs, adicionar funcionalidades ou lidar com incidentes com segurança sem entender a base de código."
            }
        ]
    },
    {
        "id": "principal_09_cloud_oath",
        "title": "O Juramento do Engenheiro",
        "description": "Você chegou ao fim. O que define um Distinguished Engineer?",
        "context_code": null,
        "category": "domain_modeling",
        "required_stage": "Principal",
        "region": "Cloud Valley",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "Alguém que conhece todas as linguagens e frameworks",
                "is_correct": false,
                "explanation": "Conhecimento de ferramentas não é engenharia. Um distinguished engineer entende princípios que transcendem qualquer tecnologia específica."
            },
            {
                "text": "Alguém que escreve código que não quebra quando o mundo muda -- porque pensa em contratos, invariantes e trade-offs",
                "is_correct": true,
                "explanation": "GARAGE não forma programadores. GARAGE forma engenheiros. Você entende domínio. Respeita estado. Pensa em invariantes. Não escreve código frágil. Agora você é capaz de construir software que sobrevive."
            },
            {
                "text": "Alguem com mais estrelas e seguidores no GitHub",
                "is_correct": false,
                "explanation": "Popularidade não é competência em engenharia. Os melhores engenheiros frequentemente trabalham em sistemas que você nunca verá -- porque são críticos demais para falhar."
            }
        ]
    },
    {
        "id": "junior_07_disney_oop_encapsulation",
        "title": "Encapsulamento: Proteja seus Dados",
        "description": "Em OOP, por que devemos tornar atributos privados e fornecer métodos de acesso?",
        "context_code": "// A) public class User { public String name; }\n// B) public class User { private String name; public String getName() { return name; } }",
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Disney",
        "mentor": null,
        "points_on_correct": 150,
        "options": [
            {
                "text": "Atributos públicos são melhores porque acessamos diretamente sem burocracia",
                "is_correct": false,
                "explanation": "Acesso direto a atributos permite que qualquer código externo modifique o estado sem validação, quebrando invariantes."
            },
            {
                "text": "Encapsulamento protege o estado interno. Getters e setters controlam o acesso e permitem validação",
                "is_correct": true,
                "explanation": "Encapsulamento é o primeiro pilar da OOP. Sem ele, qualquer parte do sistema pode corromper o estado de um objeto."
            },
            {
                "text": "Depende da linguagem: em Java sim, em Python não",
                "is_correct": false,
                "explanation": "O princípio de encapsulamento é universal. Python usa convenção (underscore), mas o conceito é o mesmo."
            }
        ]
    },
    {
        "id": "junior_08_disney_oop_interface",
        "title": "Interface vs Classe Abstrata",
        "description": "Qual é a diferença principal entre interface e classe abstrata em Java?",
        "context_code": "// interface Drawable { void draw(); }\n// abstract class Shape { abstract void draw(); void info() { ... } }",
        "category": "domain_modeling",
        "required_stage": "Junior",
        "region": "Disney",
        "mentor": null,
        "points_on_correct": 150,
        "options": [
            {
                "text": "Não há diferença, são a mesma coisa",
                "is_correct": false,
                "explanation": "Interface define apenas contratos (o que fazer). Classe abstrata pode ter implementação parcial (como fazer)."
            },
            {
                "text": "Interface define um contrato puro (apenas assinaturas). Classe abstrata pode conter implementação parcial e estado",
                "is_correct": true,
                "explanation": "Uma classe pode implementar múltiplas interfaces, mas só pode estender uma classe abstrata. Interfaces promovem desacoplamento."
            },
            {
                "text": "Classes abstratas são mais modernas e devem sempre substituir interfaces",
                "is_correct": false,
                "explanation": "Cada uma tem seu propósito. Interfaces definem contratos. Classes abstratas compartilham implementação base."
            }
        ]
    },
    {
        "id": "junior_09_disney_oop_polymorphism",
        "title": "Polimorfismo na Prática",
        "description": "O que acontece quando chamamos um método de uma interface sem saber qual classe concreta está por trás?",
        "context_code": "Personagem p = new Heroi();\np.acao(); // O que executa?",
        "category": "logic",
        "required_stage": "Junior",
        "region": "Disney",
        "mentor": null,
        "points_on_correct": 150,
        "options": [
            {
                "text": "Executa um método genérico padrão da interface",
                "is_correct": false,
                "explanation": "Interfaces não têm implementação padrão (em versões clássicas). O método concreto da classe é executado."
            },
            {
                "text": "Java resolve em tempo de execução qual implementação chamar, baseado no tipo real do objeto (Heroi)",
                "is_correct": true,
                "explanation": "Isso é polimorfismo dinâmico (late binding). O JVM determina em runtime qual método executar baseado no tipo concreto."
            },
            {
                "text": "Dá erro de compilação porque a interface não tem corpo de método",
                "is_correct": false,
                "explanation": "Não dá erro. A variável é do tipo interface, mas o objeto real é Heroi, que implementa o método."
            }
        ]
    },
    {
        "id": "mid_07_ibm_stack_applications",
        "title": "Aplicações de Stack",
        "description": "Qual é a aplicação mais clássica de uma Stack em ciência da computação?",
        "context_code": "// Stack é usada em:\n// A) Ordenação de arrays\n// B) Validação de parênteses e expressões\n// C) Cache de páginas web",
        "category": "logic",
        "required_stage": "Mid",
        "region": "IBM",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Ordenação de arrays, pois a Stack organiza elementos naturalmente",
                "is_correct": false,
                "explanation": "Stack não é usada para ordenação. Algoritmos de ordenação usam comparações e trocas, não LIFO."
            },
            {
                "text": "Validação de parênteses: cada abertura é empilhada, cada fechamento é comparado com o topo",
                "is_correct": true,
                "explanation": "Compiladores, IDEs e parsers usam stacks para validar expressões. É a aplicação #1 de Stack em entrevistas."
            },
            {
                "text": "Cache de páginas, pois a Stack guarda as páginas mais recentes",
                "is_correct": false,
                "explanation": "Cache usa HashMap + LinkedList (LRU), não Stack. Cache precisa de acesso O(1) por chave."
            }
        ]
    },
    {
        "id": "mid_08_ibm_expression_parsing",
        "title": "Parsing de Expressões",
        "description": "Um compilador encontra a expressão ((a + b) * c). Como ele verifica se os parênteses estão corretos?",
        "context_code": "// Entrada: ((a + b) * c)\n// Como garantir que cada ( tem um ) correspondente?",
        "category": "logic",
        "required_stage": "Mid",
        "region": "IBM",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "Conta o número total de ( e ). Se forem iguais, está correto",
                "is_correct": false,
                "explanation": "Contar não basta. A string ')(' tem quantidades iguais mas está incorreta. A ordem importa."
            },
            {
                "text": "Usa uma Stack: empilha cada (, desempilha ao encontrar ). Se a Stack ficar vazia no final, está válido",
                "is_correct": true,
                "explanation": "A Stack garante que cada fechamento corresponde à abertura mais recente. Se tentar desempilhar com stack vazia, há erro."
            },
            {
                "text": "Usa expressão regular para verificar o padrão",
                "is_correct": false,
                "explanation": "Regex não consegue validar parênteses aninhados de profundidade arbitrária. Esse é um problema de gramática livre de contexto."
            }
        ]
    },
    {
        "id": "mid_09_ibm_time_complexity",
        "title": "Complexidade de Operações em Stack",
        "description": "Qual é a complexidade de tempo das operações push() e pop() em uma Stack?",
        "context_code": "Stack<Integer> stack = new Stack<>();\nstack.push(42);  // ?\nstack.pop();     // ?",
        "category": "logic",
        "required_stage": "Mid",
        "region": "IBM",
        "mentor": null,
        "points_on_correct": 200,
        "options": [
            {
                "text": "O(n) porque precisa reorganizar os elementos",
                "is_correct": false,
                "explanation": "Stack não reorganiza nada. Operações são sempre no topo, sem deslocar elementos."
            },
            {
                "text": "O(1) -- constante. Sempre opera no topo, sem percorrer elementos",
                "is_correct": true,
                "explanation": "Push e pop são O(1) amortizado. A Stack acessa apenas o topo, independente de quantos elementos contém."
            },
            {
                "text": "O(log n) porque usa busca binária internamente",
                "is_correct": false,
                "explanation": "Stack não faz busca binária. É uma estrutura LIFO simples: inserção e remoção sempre no topo."
            }
        ]
    },
    {
        "id": "senior_10_paypal_string_hashing",
        "title": "Hashing de Strings para Detecção",
        "description": "Por que HashMap é ideal para detectar duplicatas em processamento de transações?",
        "context_code": "// Milhões de transações por segundo\n// Preciso verificar se uma transação já foi processada\n// A) Loop comparando todas: O(n²)\n// B) HashMap com ID da transação: O(1) por lookup",
        "category": "logic",
        "required_stage": "Senior",
        "region": "PayPal",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "HashMap não é confiável para dados financeiros por causa de colisões",
                "is_correct": false,
                "explanation": "Colisões existem mas são raras e tratáveis. HashMap oferece O(1) amortizado, essencial para alta performance."
            },
            {
                "text": "HashMap permite busca O(1) por chave, transformando verificação de duplicatas de O(n²) para O(n)",
                "is_correct": true,
                "explanation": "Em PayPal, cada transação tem um ID único. HashMap armazena IDs processados e verifica em tempo constante."
            },
            {
                "text": "Melhor usar um banco de dados relacional para cada verificação",
                "is_correct": false,
                "explanation": "Bancos de dados têm latência de milissegundos. Para milhões de transações/segundo, verificação in-memory é essencial."
            }
        ]
    },
    {
        "id": "senior_11_paypal_anagram_fraud",
        "title": "Comparação de Strings em Fraude",
        "description": "Para detectar variações fraudulentas de nomes, qual técnica de comparação de strings é mais eficiente?",
        "context_code": "// 'John Smith' vs 'Smith John' -- é a mesma pessoa?\n// 'paypal' vs 'paypla' -- typosquatting?",
        "category": "logic",
        "required_stage": "Senior",
        "region": "PayPal",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Comparar caractere por caractere com equals()",
                "is_correct": false,
                "explanation": "equals() detecta igualdade exata, mas não detecta anagramas, typos ou reorganizações."
            },
            {
                "text": "Contagem de frequência de caracteres: se duas strings têm as mesmas letras nas mesmas quantidades, são anagramas",
                "is_correct": true,
                "explanation": "Contagem de frequência é O(n) e detecta anagramas. Combinado com distância de Levenshtein, detecta typosquatting."
            },
            {
                "text": "Ordenar ambas as strings e comparar, sempre",
                "is_correct": false,
                "explanation": "Ordenar funciona para anagramas mas é O(n log n). Contagem de frequência é O(n) -- mais eficiente."
            }
        ]
    },
    {
        "id": "senior_12_paypal_idempotency",
        "title": "Idempotência em Pagamentos",
        "description": "O que é idempotência e por que é crítica em sistemas de pagamento?",
        "context_code": "// Usuário clica 'Pagar' duas vezes\n// O sistema deve cobrar uma ou duas vezes?",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "PayPal",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "O sistema deve processar todas as requisições recebidas fielmente",
                "is_correct": false,
                "explanation": "Processar duplicatas causa cobranças duplas. Em pagamentos, isso é inaceitável."
            },
            {
                "text": "Idempotência garante que múltiplas chamadas idênticas produzem o mesmo resultado. A segunda chamada é ignorada",
                "is_correct": true,
                "explanation": "Cada requisição leva um idempotency key. Se a chave já foi processada, retorna o resultado anterior sem reprocessar."
            },
            {
                "text": "O frontend deve impedir o duplo clique, não é responsabilidade do backend",
                "is_correct": false,
                "explanation": "O frontend ajuda, mas não é confiável. Redes podem duplicar pacotes. O backend DEVE ser idempotente."
            }
        ]
    },
    {
        "id": "senior_13_netflix_sliding_window",
        "title": "Técnica Sliding Window",
        "description": "Qual é a vantagem da técnica sliding window sobre força bruta para encontrar subarrays ótimos?",
        "context_code": "// Encontrar o subarray de soma máxima\n// A) Testar todos os subarrays possíveis: O(n³)\n// B) Sliding window / Kadane: O(n)",
        "category": "logic",
        "required_stage": "Senior",
        "region": "Netflix",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Sliding window usa mais memória mas é mais legível",
                "is_correct": false,
                "explanation": "Sliding window usa O(1) de memória extra. A vantagem é tempo, não legibilidade."
            },
            {
                "text": "Sliding window mantém uma janela que desliza pelo array, evitando recálculos. Reduz O(n³) ou O(n²) para O(n)",
                "is_correct": true,
                "explanation": "A janela aproveita o cálculo anterior: ao deslizar, adiciona o novo elemento e remove o antigo. Sem recalcular do zero."
            },
            {
                "text": "Sliding window só funciona para arrays ordenados",
                "is_correct": false,
                "explanation": "Sliding window funciona em arrays não ordenados. O algoritmo de Kadane, por exemplo, não requer ordenação."
            }
        ]
    },
    {
        "id": "senior_14_netflix_recommendation",
        "title": "Otimização de Streaming",
        "description": "Netflix processa bilhões de eventos de visualização. Qual estrutura é melhor para contar os filmes mais assistidos?",
        "context_code": "// Entrada: stream de eventos {userId, movieId, timestamp}\n// Saída: top 10 filmes mais assistidos",
        "category": "architecture",
        "required_stage": "Senior",
        "region": "Netflix",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Array ordenado, reinserindo a cada novo evento",
                "is_correct": false,
                "explanation": "Reinserir em array ordenado é O(n) por evento. Para bilhões de eventos, é inviável."
            },
            {
                "text": "HashMap para contagem + PriorityQueue (min-heap de tamanho 10) para manter o top 10",
                "is_correct": true,
                "explanation": "HashMap conta em O(1). Min-heap de tamanho k mantém os k maiores em O(n log k). Eficiente para streaming."
            },
            {
                "text": "Banco de dados com ORDER BY e LIMIT 10",
                "is_correct": false,
                "explanation": "Funciona para consultas batch, mas para streaming em tempo real, a latência do banco é proibitiva."
            }
        ]
    },
    {
        "id": "senior_15_netflix_time_series",
        "title": "Análise de Séries Temporais",
        "description": "Para detectar picos de audiência em tempo real, qual abordagem algorítmica é mais adequada?",
        "context_code": "// Audiência nos últimos 60 segundos\n// Detectar se houve um pico repentino",
        "category": "logic",
        "required_stage": "Senior",
        "region": "Netflix",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Recalcular a média de todos os dados históricos a cada segundo",
                "is_correct": false,
                "explanation": "Recalcular tudo é O(n) por segundo e cresce indefinidamente. Insustentável para streaming."
            },
            {
                "text": "Janela deslizante de tamanho fixo: mantém apenas os últimos N segundos e atualiza incrementalmente",
                "is_correct": true,
                "explanation": "Sliding window de tamanho fixo: adiciona novo, remove antigo. Atualização O(1) por evento. Memória constante."
            },
            {
                "text": "Armazenar tudo em disco e processar em batch a cada hora",
                "is_correct": false,
                "explanation": "Batch processing tem latência de horas. Detecção de picos precisa ser em tempo real (segundos)."
            }
        ]
    },
    {
        "id": "staff_10_spacex_deduplication",
        "title": "Deduplicação em Telemetria",
        "description": "Sensores de um foguete enviam dados duplicados por redundância. Como eliminar duplicatas eficientemente?",
        "context_code": "// 10.000 leituras/segundo de 200 sensores\n// Muitas leituras são duplicadas por segurança\n// Precisamos: dados únicos, em tempo real",
        "category": "logic",
        "required_stage": "Staff",
        "region": "SpaceX",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Comparar cada leitura com todas as anteriores: loop O(n²)",
                "is_correct": false,
                "explanation": "O(n²) para 10.000 leituras/segundo é impraticável. Em sistemas de tempo real, latência é questão de vida."
            },
            {
                "text": "HashSet: add() retorna false se o elemento já existe. Verificação e inserção O(1)",
                "is_correct": true,
                "explanation": "HashSet usa hash function para verificação instantânea. Ideal para deduplicação em streaming de alta frequência."
            },
            {
                "text": "Ordenar os dados e remover adjacentes iguais",
                "is_correct": false,
                "explanation": "Ordenar é O(n log n) e altera a ordem temporal dos dados. Em telemetria, a ordem cronológica é crítica."
            }
        ]
    },
    {
        "id": "staff_11_spacex_set_operations",
        "title": "Operações de Conjunto",
        "description": "Dois sistemas redundantes do foguete reportam conjuntos de falhas. Como encontrar falhas comuns a ambos?",
        "context_code": "Set<String> systemA = {\"engine_temp\", \"fuel_low\", \"vibration\"};\nSet<String> systemB = {\"fuel_low\", \"pressure_drop\", \"vibration\"};",
        "category": "logic",
        "required_stage": "Staff",
        "region": "SpaceX",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Dois loops aninhados comparando cada elemento: O(n*m)",
                "is_correct": false,
                "explanation": "Loops aninhados são O(n*m). Com HashSet, a interseção é O(min(n,m))."
            },
            {
                "text": "retainAll() de HashSet calcula a interseção em O(n). Falhas comuns são as mais críticas",
                "is_correct": true,
                "explanation": "Se ambos os sistemas detectam a mesma falha, a confiança é alta. Interseção de sets é operação fundamental."
            },
            {
                "text": "Concatenar as duas listas e contar frequências manualmente",
                "is_correct": false,
                "explanation": "Funciona mas é ineficiente e verboso. Set.retainAll() é a operação semântica exata para interseção."
            }
        ]
    },
    {
        "id": "staff_12_spacex_realtime_constraints",
        "title": "Restrições de Tempo Real",
        "description": "Em software de controle de foguetes, qual complexidade algorítmica é aceitável para operações críticas?",
        "context_code": "// Loop de controle roda a cada 10ms\n// Cada operação deve completar em microssegundos",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "SpaceX",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "O(n log n) é aceitável para todas as operações",
                "is_correct": false,
                "explanation": "Em tempo real hard, até O(n log n) pode estourar o deadline. Operações críticas devem ser O(1) ou O(log n)."
            },
            {
                "text": "Operações críticas devem ser O(1). Estruturas como HashSet e HashMap garantem tempo constante previsível",
                "is_correct": true,
                "explanation": "Sistemas de tempo real exigem latência previsível. O(1) amortizado é o padrão para controle de voo."
            },
            {
                "text": "A complexidade não importa se o hardware for rápido o suficiente",
                "is_correct": false,
                "explanation": "Hardware rápido não compensa algoritmos ruins. Um O(n²) com n grande estoura qualquer hardware."
            }
        ]
    },
    {
        "id": "staff_13_nvidia_merge_vs_quick",
        "title": "Merge Sort vs Quick Sort",
        "description": "Quando escolher Merge Sort ao invés de Quick Sort?",
        "context_code": "// Merge Sort: O(n log n) garantido, estável, usa O(n) memória extra\n// Quick Sort: O(n log n) médio, O(n²) pior caso, in-place",
        "category": "logic",
        "required_stage": "Staff",
        "region": "Nvidia",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Quick Sort é sempre melhor porque é mais rápido na prática",
                "is_correct": false,
                "explanation": "Quick Sort é rápido na média, mas O(n²) no pior caso. Para dados críticos, isso é inaceitável."
            },
            {
                "text": "Merge Sort quando precisamos de garantia O(n log n), estabilidade (manter ordem de iguais), ou ordenar linked lists",
                "is_correct": true,
                "explanation": "Merge Sort é estável e sempre O(n log n). Ideal para linked lists (sem acesso aleatório) e quando estabilidade importa."
            },
            {
                "text": "Merge Sort é obsoleto, Java já usa Arrays.sort() internamente",
                "is_correct": false,
                "explanation": "Java usa TimSort (baseado em Merge Sort!) para objetos. Entender Merge Sort é entender o que Java faz por baixo."
            }
        ]
    },
    {
        "id": "staff_14_nvidia_divide_conquer",
        "title": "Dividir e Conquistar",
        "description": "Qual é o princípio fundamental do paradigma 'dividir e conquistar'?",
        "context_code": "// Merge Sort, Quick Sort, Binary Search\n// Todos seguem o mesmo padrão...",
        "category": "logic",
        "required_stage": "Staff",
        "region": "Nvidia",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Resolver o problema usando força bruta e depois otimizar",
                "is_correct": false,
                "explanation": "Força bruta não divide nada. Dividir e conquistar é uma estratégia de decomposição, não otimização pós-fato."
            },
            {
                "text": "Dividir o problema em subproblemas menores, resolver cada um, e combinar as soluções",
                "is_correct": true,
                "explanation": "Dividir (split), conquistar (resolver recursivamente), combinar (merge). Reduz O(n²) para O(n log n) em muitos casos."
            },
            {
                "text": "Distribuir o trabalho entre múltiplas threads automaticamente",
                "is_correct": false,
                "explanation": "Paralelismo é uma aplicação possível, mas D&C é um paradigma algorítmico, não uma técnica de threading."
            }
        ]
    },
    {
        "id": "staff_15_nvidia_sorting_stability",
        "title": "Estabilidade em Ordenação",
        "description": "O que significa um algoritmo de ordenação ser 'estável'?",
        "context_code": "// [{nome: 'Ana', idade: 25}, {nome: 'Bob', idade: 25}]\n// Ordenar por idade. Ana deve vir antes de Bob?",
        "category": "logic",
        "required_stage": "Staff",
        "region": "Nvidia",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "O algoritmo nunca falha ou causa erros",
                "is_correct": false,
                "explanation": "'Estável' em sorting não significa 'sem bugs'. É uma propriedade sobre a ordem de elementos iguais."
            },
            {
                "text": "Elementos com chaves iguais mantêm sua ordem relativa original. Ana continua antes de Bob",
                "is_correct": true,
                "explanation": "Merge Sort é estável. Quick Sort e Heap Sort não são. Estabilidade importa quando há ordenação por múltiplos critérios."
            },
            {
                "text": "O algoritmo usa sempre a mesma quantidade de memória",
                "is_correct": false,
                "explanation": "Isso seria 'in-place', não 'estável'. São propriedades diferentes de algoritmos de ordenação."
            }
        ]
    },
    {
        "id": "staff_16_openai_graph_representation",
        "title": "Representação de Grafos",
        "description": "Qual é a forma mais eficiente de representar um grafo esparso (poucos arestas por nó)?",
        "context_code": "// Grafo com 1 milhão de nós, cada um com ~10 conexões\n// A) Matriz de adjacência: int[1M][1M]\n// B) Lista de adjacência: Map<Node, List<Node>>",
        "category": "logic",
        "required_stage": "Staff",
        "region": "OpenAI",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Matriz de adjacência: acesso O(1) para verificar se dois nós estão conectados",
                "is_correct": false,
                "explanation": "Matriz O(1) é verdade, mas para 1M nós, a matriz ocupa 1M x 1M = 1 trilhão de posições. Impossível."
            },
            {
                "text": "Lista de adjacência: usa memória proporcional ao número de arestas O(V+E), não ao quadrado dos nós",
                "is_correct": true,
                "explanation": "Para grafos esparsos, lista de adjacência é O(V+E). Com 1M nós e 10M arestas, usa ~10M de memória, não 1T."
            },
            {
                "text": "Não faz diferença, ambas usam a mesma memória",
                "is_correct": false,
                "explanation": "Matriz usa O(V²), lista usa O(V+E). Para grafos esparsos, a diferença é de ordens de magnitude."
            }
        ]
    },
    {
        "id": "staff_17_openai_bfs_vs_dfs",
        "title": "BFS vs DFS",
        "description": "Quando usar BFS (Busca em Largura) ao invés de DFS (Busca em Profundidade)?",
        "context_code": "// BFS: visita por camadas (Queue)\n// DFS: vai até o fundo primeiro (Stack/recursão)",
        "category": "logic",
        "required_stage": "Staff",
        "region": "OpenAI",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "BFS é sempre mais rápido que DFS",
                "is_correct": false,
                "explanation": "Ambos visitam todos os nós acessíveis: O(V+E). A diferença é a ORDEM de visitação, não a velocidade."
            },
            {
                "text": "BFS encontra o caminho mais curto (em número de arestas). DFS é melhor para explorar caminhos completos",
                "is_correct": true,
                "explanation": "BFS garante menor distância em grafos não-ponderados. DFS é útil para detecção de ciclos, topological sort e backtracking."
            },
            {
                "text": "DFS é obsoleto e BFS deve ser usado sempre",
                "is_correct": false,
                "explanation": "DFS é essencial: topological sort, detecção de ciclos, componentes fortemente conectados. Cada um tem seu uso."
            }
        ]
    },
    {
        "id": "staff_18_openai_neural_graphs",
        "title": "Grafos em Redes Neurais",
        "description": "Por que redes neurais podem ser modeladas como grafos direcionados?",
        "context_code": "// Camada de entrada → Camada oculta → Camada de saída\n// Cada neurônio conecta a neurônios da próxima camada",
        "category": "architecture",
        "required_stage": "Staff",
        "region": "OpenAI",
        "mentor": null,
        "points_on_correct": 250,
        "options": [
            {
                "text": "Redes neurais não são grafos, são matrizes de pesos",
                "is_correct": false,
                "explanation": "Matrizes de pesos REPRESENTAM as arestas do grafo. Cada peso é uma aresta entre dois neurônios."
            },
            {
                "text": "Cada neurônio é um nó. Cada conexão (com peso) é uma aresta direcionada. Forward propagation é uma travessia do grafo",
                "is_correct": true,
                "explanation": "Forward pass = travessia topológica do grafo. Backpropagation = travessia reversa. Grafos são a base da IA."
            },
            {
                "text": "Grafos são apenas uma analogia visual, não têm aplicação computacional real em IA",
                "is_correct": false,
                "explanation": "Graph Neural Networks (GNN) são uma área inteira de pesquisa. Grafos são estrutura fundamental em IA moderna."
            }
        ]
    },
    {
        "id": "principal_10_gemini_heap_property",
        "title": "Propriedade do Heap",
        "description": "O que define um Min-Heap e por que é eficiente para filas de prioridade?",
        "context_code": "// PriorityQueue em Java é um Min-Heap\n// O menor elemento está sempre na raiz",
        "category": "logic",
        "required_stage": "Principal",
        "region": "Gemini",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "Min-Heap é um array ordenado onde o menor está na posição 0",
                "is_correct": false,
                "explanation": "Heap NÃO é totalmente ordenado. Apenas garante que o pai é menor que os filhos. Ordenação parcial."
            },
            {
                "text": "Min-Heap é uma árvore binária onde cada pai é menor que seus filhos. Extração do mínimo é O(log n)",
                "is_correct": true,
                "explanation": "A raiz é sempre o menor. Inserir e remover são O(log n) porque a árvore tem altura log n. Ideal para 'próximo mais urgente'."
            },
            {
                "text": "Heap é igual a uma BST (árvore binária de busca)",
                "is_correct": false,
                "explanation": "BST garante left < parent < right. Heap garante parent < filhos (ambos). São propriedades diferentes."
            }
        ]
    },
    {
        "id": "principal_11_gemini_dijkstra",
        "title": "Heap em Algoritmos de Busca",
        "description": "Por que o algoritmo de Dijkstra (caminho mais curto) usa uma PriorityQueue?",
        "context_code": "// Dijkstra: encontrar caminho mais curto de A até todos os outros nós\n// Precisa sempre processar o nó mais próximo primeiro",
        "category": "logic",
        "required_stage": "Principal",
        "region": "Gemini",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "PriorityQueue é usada apenas para facilitar a implementação, não é necessária",
                "is_correct": false,
                "explanation": "Sem PriorityQueue, encontrar o próximo nó mínimo é O(V). Com heap, é O(log V). Muda a complexidade total."
            },
            {
                "text": "PriorityQueue permite extrair o nó de menor distância em O(log n), tornando Dijkstra O((V+E) log V)",
                "is_correct": true,
                "explanation": "Sem heap: O(V²). Com heap: O((V+E) log V). Para grafos grandes, a diferença é de minutos para milissegundos."
            },
            {
                "text": "Dijkstra não precisa de heap, BFS resolve o mesmo problema",
                "is_correct": false,
                "explanation": "BFS encontra menor caminho em grafos NÃO ponderados. Dijkstra resolve grafos com pesos diferentes nas arestas."
            }
        ]
    },
    {
        "id": "principal_12_gemini_comparable",
        "title": "Comparable vs Comparator",
        "description": "Qual é a diferença entre Comparable e Comparator em Java para definir ordem de prioridade?",
        "context_code": "// class Task implements Comparable<Task> { compareTo(Task o) {} }\n// PriorityQueue<Task> pq = new PriorityQueue<>(Comparator.comparing(Task::getPriority));",
        "category": "domain_modeling",
        "required_stage": "Principal",
        "region": "Gemini",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "Não há diferença, são sinônimos em Java",
                "is_correct": false,
                "explanation": "Comparable é implementado NA classe (ordem natural). Comparator é EXTERNO (ordem customizada)."
            },
            {
                "text": "Comparable define a ordem natural do objeto. Comparator permite múltiplas ordens externas sem modificar a classe",
                "is_correct": true,
                "explanation": "Comparable: uma classe, uma ordem. Comparator: múltiplas estratégias de ordenação. Open/Closed Principle aplicado."
            },
            {
                "text": "Comparator é mais lento porque é uma classe separada",
                "is_correct": false,
                "explanation": "Performance é idêntica. A diferença é de design: encapsulamento da lógica de comparação."
            }
        ]
    },
    {
        "id": "principal_13_claude_dp_concept",
        "title": "O Que é Programação Dinâmica?",
        "description": "Qual é a ideia central da Programação Dinâmica (DP)?",
        "context_code": "// Fibonacci recursivo: fib(5) chama fib(4)+fib(3)\n// fib(4) chama fib(3)+fib(2) -- fib(3) calculado 2x!",
        "category": "logic",
        "required_stage": "Principal",
        "region": "Claude",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "DP é uma forma avançada de usar loops for",
                "is_correct": false,
                "explanation": "DP não é apenas sobre loops. É sobre identificar subproblemas sobrepostos e eliminá-los."
            },
            {
                "text": "DP resolve problemas decompondo em subproblemas, memorizando resultados já calculados para evitar recomputação",
                "is_correct": true,
                "explanation": "Memoização (top-down) ou tabulação (bottom-up). Transforma exponencial O(2^n) em polinomial O(n)."
            },
            {
                "text": "DP é sinônimo de recursão com múltiplas chamadas",
                "is_correct": false,
                "explanation": "Recursão sem memoização recalcula subproblemas. DP elimina essa redundância armazenando resultados."
            }
        ]
    },
    {
        "id": "principal_14_claude_dp_vs_greedy",
        "title": "DP vs Algoritmo Guloso",
        "description": "Quando usar Programação Dinâmica ao invés de um algoritmo guloso?",
        "context_code": "// Troco de moedas: moedas = [1, 5, 10, 25]\n// Valor: 30 centavos. Mínimo de moedas?",
        "category": "logic",
        "required_stage": "Principal",
        "region": "Claude",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "Greedy é sempre mais rápido, então deve ser usado sempre que possível",
                "is_correct": false,
                "explanation": "Greedy é rápido mas nem sempre correto. Para moedas {1, 3, 4}, greedy falha para valor 6 (4+1+1=3 moedas, mas 3+3=2)."
            },
            {
                "text": "DP quando a escolha ótima local não garante a solução global. DP explora todas as combinações eficientemente",
                "is_correct": true,
                "explanation": "Greedy: escolha local ótima (funciona para moedas padrão). DP: quando precisa considerar todas as possibilidades."
            },
            {
                "text": "DP substitui Greedy em todos os casos",
                "is_correct": false,
                "explanation": "DP é mais poderoso mas mais lento. Se Greedy funciona (provado correto), é preferível por ser O(n) ou O(n log n)."
            }
        ]
    },
    {
        "id": "principal_15_claude_memoization",
        "title": "Top-Down vs Bottom-Up",
        "description": "Qual é a diferença entre memoização (top-down) e tabulação (bottom-up) em DP?",
        "context_code": "// Top-down: fib(n) = fib(n-1) + fib(n-2) com cache\n// Bottom-up: dp[0]=0, dp[1]=1, dp[i]=dp[i-1]+dp[i-2]",
        "category": "logic",
        "required_stage": "Principal",
        "region": "Claude",
        "mentor": null,
        "points_on_correct": 300,
        "options": [
            {
                "text": "Top-down é sempre mais rápido porque evita calcular subproblemas desnecessários",
                "is_correct": false,
                "explanation": "Top-down pode ser mais rápido se poucos subproblemas são acessados. Mas tem overhead de recursão e cache lookup."
            },
            {
                "text": "Top-down usa recursão + cache (memoização). Bottom-up usa loop preenchendo uma tabela. Ambos evitam recomputação",
                "is_correct": true,
                "explanation": "Top-down é mais intuitivo (pensa do problema grande para baixo). Bottom-up é iterativo e geralmente mais eficiente em memória."
            },
            {
                "text": "São abordagens completamente diferentes que resolvem problemas diferentes",
                "is_correct": false,
                "explanation": "Ambas resolvem os mesmos problemas. São duas implementações da mesma ideia: reutilizar resultados de subproblemas."
            }
        ]
    }
]
